#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const BaseAdapter = require("./base-adapter");
const {
  stripClaudeFrontmatter,
  stripClaudeDirectives,
} = require("./content-utils");

const BEST_EFFORT_HEADER = "<!-- Generated by refactoring-kit. Best-effort format — may need adjustment for your Qoder version. -->\n\n";

/** Command files with mode mapping */
const COMMAND_FILES = [
  { src: "commands/refactor/review.md", name: "refactoring-review", mode: "Agent Mode" },
  { src: "commands/refactor/fast.md", name: "refactoring-fast", mode: "Agent Mode" },
  { src: "commands/refactor/plan.md", name: "refactoring-plan", mode: "Quest Mode" },
  { src: "commands/refactor/implement.md", name: "refactoring-implement", mode: "Quest Mode" },
  { src: "commands/refactor/architecture.md", name: "refactoring-architecture", mode: "Agent Mode" },
];

/** Key metrics to inline (since Qoder may not load separate reference files) */
const INLINED_METRICS = [
  "",
  "## Inlined Reference: Key Metrics",
  "",
  "| Metric | Threshold | Severity |",
  "|--------|-----------|----------|",
  "| Cyclomatic complexity | >10 method, >20 class | major |",
  "| Method length | >30 lines | major |",
  "| Class length | >300 lines | major |",
  "| Parameter count | >4 parameters | minor |",
  "| Nesting depth | >3 levels | major |",
  "| Duplication | >3 occurrences | major |",
  "| Coupling (afferent) | >10 dependents | major |",
  "",
  "**Priority order:** Security > Correctness > Structure > Duplication > Naming > Style",
  "",
].join("\n");

/**
 * Qoder adapter — best-effort support for Qoder agentic IDE.
 * Installs markdown rules in .qoder/rules/ with inlined reference content.
 * Maps workflows to Qoder's Agent Mode (quick tasks) and Quest Mode (complex tasks).
 * Format based on limited documentation — labeled as best effort.
 * Project-only (no global scope).
 */
class QoderAdapter extends BaseAdapter {
  get name() {
    return "qoder";
  }

  get displayName() {
    return "Qoder";
  }

  get capabilities() {
    return {
      slashCommands: false,
      workflows: false,
      separateReferences: false,
      fileGlobs: false,
      bestEffort: true,
    };
  }

  getInstallPath(scope, projectRoot) {
    if (scope === "global") return null;
    return path.join(projectRoot, ".qoder");
  }

  install({ packageDir, scope, projectRoot, dryRun = false }) {
    if (scope === "global") {
      return {
        success: false,
        files: [],
        message: "Qoder does not support global install. Use --tool=qoder without --global.",
      };
    }

    const qoderDir = this.getInstallPath(scope, projectRoot);
    const rulesDir = path.join(qoderDir, "rules");
    const files = [];

    // 1. Main skill rule
    const skillContent = this.readCanonical(packageDir, "SKILL.md");
    if (!skillContent) {
      return { success: false, files: [], message: "SKILL.md not found in package" };
    }
    files.push(path.join(rulesDir, "refactoring-skill.md"));

    // 2. Command rules
    for (const cmd of COMMAND_FILES) {
      const content = this.readCanonical(packageDir, cmd.src);
      if (content) {
        files.push(path.join(rulesDir, `${cmd.name}.md`));
      }
    }

    // 3. Marker
    files.push(path.join(qoderDir, this.markerFile));

    if (dryRun) {
      return { success: true, files, message: `Would install to ${qoderDir} (best-effort format)` };
    }

    // --- Actual install ---

    // Skill rule with inlined metrics
    let adapted = stripClaudeFrontmatter(skillContent);
    adapted = stripClaudeDirectives(adapted);
    this.writeFile(
      path.join(rulesDir, "refactoring-skill.md"),
      BEST_EFFORT_HEADER + adapted + INLINED_METRICS
    );

    // Command rules with mode hints
    for (const cmd of COMMAND_FILES) {
      const content = this.readCanonical(packageDir, cmd.src);
      if (!content) continue;
      let cmdAdapted = stripClaudeFrontmatter(content);
      cmdAdapted = stripClaudeDirectives(cmdAdapted);
      cmdAdapted = cmdAdapted.replace(/\$ARGUMENTS/g, "the user's request");
      const modeHint = `\n\n> **Qoder mode:** Best used in ${cmd.mode}.\n`;
      this.writeFile(
        path.join(rulesDir, `${cmd.name}.md`),
        BEST_EFFORT_HEADER + cmdAdapted + modeHint
      );
    }

    // Marker
    this.writeMarker(qoderDir);

    console.warn(`  ⚠  Qoder adapter: best-effort support. Format based on limited public docs.`);
    console.log(`Installed refactoring skill for Qoder`);
    return { success: true, files, message: `Installed to ${qoderDir}` };
  }

  uninstall({ scope, projectRoot, dryRun = false }) {
    if (scope === "global") {
      return { success: true, message: "Qoder does not use global install — nothing to remove" };
    }

    const qoderDir = this.getInstallPath(scope, projectRoot);

    if (!this.hasMarker(qoderDir)) {
      return { success: true, message: "Not installed for Qoder — nothing to remove" };
    }

    if (dryRun) {
      return { success: true, message: `Would remove Qoder files from ${qoderDir}` };
    }

    // Remove rules
    const rulesDir = path.join(qoderDir, "rules");
    const skillFile = path.join(rulesDir, "refactoring-skill.md");
    if (fs.existsSync(skillFile)) fs.unlinkSync(skillFile);

    for (const cmd of COMMAND_FILES) {
      const p = path.join(rulesDir, `${cmd.name}.md`);
      if (fs.existsSync(p)) fs.unlinkSync(p);
    }

    // Marker
    this.removeMarker(qoderDir);

    console.log(`Removed refactoring skill from Qoder`);
    return { success: true, message: "Uninstalled from Qoder" };
  }
}

module.exports = QoderAdapter;
