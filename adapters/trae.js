#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const BaseAdapter = require("./base-adapter");
const {
  stripClaudeFrontmatter,
  stripClaudeDirectives,
} = require("./content-utils");

const BEST_EFFORT_HEADER = "<!-- Generated by refactoring-kit. Best-effort format — may need adjustment for your Trae version. -->\n\n";

/** Command files to convert to rules */
const COMMAND_FILES = [
  { src: "commands/refactor/review.md", name: "refactoring-review" },
  { src: "commands/refactor/fast.md", name: "refactoring-fast" },
  { src: "commands/refactor/plan.md", name: "refactoring-plan" },
  { src: "commands/refactor/implement.md", name: "refactoring-implement" },
  { src: "commands/refactor/architecture.md", name: "refactoring-architecture" },
];

/**
 * Trae adapter — best-effort support for ByteDance's Trae IDE.
 * Installs plain markdown rules in .trae/rules/ with references subdirectory.
 * Format based on limited public documentation — labeled as best effort.
 * Project-only (no global scope).
 */
class TraeAdapter extends BaseAdapter {
  get name() {
    return "trae";
  }

  get displayName() {
    return "Trae";
  }

  get capabilities() {
    return {
      slashCommands: false,
      workflows: false,
      separateReferences: true,
      fileGlobs: false,
      bestEffort: true,
    };
  }

  getInstallPath(scope, projectRoot) {
    if (scope === "global") return null;
    return path.join(projectRoot, ".trae");
  }

  install({ packageDir, scope, projectRoot, dryRun = false }) {
    if (scope === "global") {
      return {
        success: false,
        files: [],
        message: "Trae does not support global install. Use --tool=trae without --global.",
      };
    }

    const traeDir = this.getInstallPath(scope, projectRoot);
    const rulesDir = path.join(traeDir, "rules");
    const refsDir = path.join(rulesDir, "refactoring-references");
    const files = [];

    // 1. Main skill rule
    const skillContent = this.readCanonical(packageDir, "SKILL.md");
    if (!skillContent) {
      return { success: false, files: [], message: "SKILL.md not found in package" };
    }
    files.push(path.join(rulesDir, "refactoring-skill.md"));

    // 2. Command rules
    for (const cmd of COMMAND_FILES) {
      const content = this.readCanonical(packageDir, cmd.src);
      if (content) {
        files.push(path.join(rulesDir, `${cmd.name}.md`));
      }
    }

    // 3. Reference files
    const refsSrc = path.join(packageDir, "references");
    if (fs.existsSync(refsSrc)) {
      files.push(...this.collectFiles(refsSrc, refsDir));
    }

    // 4. Marker
    files.push(path.join(traeDir, this.markerFile));

    if (dryRun) {
      return { success: true, files, message: `Would install to ${traeDir} (best-effort format)` };
    }

    // --- Actual install ---

    // Skill rule
    let adapted = stripClaudeFrontmatter(skillContent);
    adapted = stripClaudeDirectives(adapted);
    this.writeFile(path.join(rulesDir, "refactoring-skill.md"), BEST_EFFORT_HEADER + adapted);

    // Command rules
    for (const cmd of COMMAND_FILES) {
      const content = this.readCanonical(packageDir, cmd.src);
      if (!content) continue;
      let cmdAdapted = stripClaudeFrontmatter(content);
      cmdAdapted = stripClaudeDirectives(cmdAdapted);
      cmdAdapted = cmdAdapted.replace(/\$ARGUMENTS/g, "the user's request");
      this.writeFile(path.join(rulesDir, `${cmd.name}.md`), BEST_EFFORT_HEADER + cmdAdapted);
    }

    // References
    if (fs.existsSync(refsSrc)) {
      this.copyRecursive(refsSrc, refsDir);
    }

    // Marker
    this.writeMarker(traeDir);

    console.warn(`  ⚠  Trae adapter: best-effort support. Format based on limited public docs.`);
    console.log(`Installed refactoring skill for Trae`);
    return { success: true, files, message: `Installed to ${traeDir}` };
  }

  uninstall({ scope, projectRoot, dryRun = false }) {
    if (scope === "global") {
      return { success: true, message: "Trae does not use global install — nothing to remove" };
    }

    const traeDir = this.getInstallPath(scope, projectRoot);

    if (!this.hasMarker(traeDir)) {
      return { success: true, message: "Not installed for Trae — nothing to remove" };
    }

    if (dryRun) {
      return { success: true, message: `Would remove Trae files from ${traeDir}` };
    }

    // Remove rules
    const rulesDir = path.join(traeDir, "rules");
    const skillFile = path.join(rulesDir, "refactoring-skill.md");
    if (fs.existsSync(skillFile)) fs.unlinkSync(skillFile);

    for (const cmd of COMMAND_FILES) {
      const p = path.join(rulesDir, `${cmd.name}.md`);
      if (fs.existsSync(p)) fs.unlinkSync(p);
    }

    // Remove references
    const refsDir = path.join(rulesDir, "refactoring-references");
    if (fs.existsSync(refsDir)) {
      fs.rmSync(refsDir, { recursive: true, force: true });
    }

    // Marker
    this.removeMarker(traeDir);

    console.log(`Removed refactoring skill from Trae`);
    return { success: true, message: "Uninstalled from Trae" };
  }
}

module.exports = TraeAdapter;
